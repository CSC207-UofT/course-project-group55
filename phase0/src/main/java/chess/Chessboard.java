package chess;

import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;

/**
 *
 */
public class Chessboard{
    final private String[] boardSetup;
    final private String[] pieceSetup;
    final int[] size;

    private Map<Coord, Piece> state = new HashMap<>();
    private playerColor turnColor;
    private Set<Character> castling = new HashSet<>();
    private Coord enPassantSquare;
    private int halfMoveClock;
    private int fullMoveNumber;


    /**
     * Generates a Chessboard from the boardSetup String.
     * @param   FEN     FEN String to be loaded. Can accept Non 8x8 board sizes.
     */
    public Chessboard(String FEN){
        boardSetup = FEN.split(" ", 0);
        pieceSetup = boardSetup[0].split("/", 0);

        try{
            size = calculateBoardSize();
        }catch (InvalidFENException e){
            throw new AssertionError(e.getMessage());
        }

        try{
            populateBoard();
        }catch (InvalidFENException e){
            throw new AssertionError(e.getMessage());
        }

        setupBoardMisc();

    }

    /**
     * Generates a Classic 8x8 Chessboard from the preset boardSetup String.
     * <p>
     * See also {@link #Chessboard(String)}
     * </p>
     */
    public Chessboard(){
        // Constructor for the classical 8x8 Chess Board
        String FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
        boardSetup = FEN.split(" ", 0);
        pieceSetup = boardSetup[0].split("/", 0);

        try{
            size = calculateBoardSize();
        }catch (InvalidFENException e){
            e.printStackTrace();
            throw new AssertionError(e.getMessage());
        }

        try{
            populateBoard();
        }catch (InvalidFENException e){
            e.printStackTrace();
            throw new AssertionError(e.getMessage());
        }

        setupBoardMisc();

    }

    /**
     * <p>
     * Calculates the shape/size of the board that will be generated by {@link #populateBoard()},
     * and assigns it to boardSize.
     * Also checks if the board has a rectangular shape.
     * </p>
     * @throws InvalidFENException   if boardSetup will not generate a rectangular board
     */
    private int[] calculateBoardSize()
            throws InvalidFENException {

        int[] boardWidth = new int[pieceSetup.length];

        // Calculate boardWidth (row length)
        for (int i = 0; i < pieceSetup.length; i++){
            for (char c: pieceSetup[i].toCharArray()) {
                if (Character.isDigit(c)) boardWidth[i] += (c - '0');
                else boardWidth[i]++;
            }
        }

        // check if generated board widths are consistent
        for (int width: boardWidth) {
            if(width != boardWidth[0])
                throw new InvalidFENException("Board shape generated by boardSetup is not rectangular.");
        }

        return new int[]{boardWidth[0], pieceSetup.length};
    }

    /**
     * Generates and assigns boardState from boardSetup.
     */
    private void populateBoard()
            throws InvalidFENException {

        Coord currCoord = new Coord(0, size[1] - 1);

        for (String row: pieceSetup) {
            for (char tileState : row.toCharArray()) {

                // If tileState is an alphabet, then generate corresponding Piece
                if(Character.isAlphabetic(tileState)) {
                    state.put(currCoord, PieceFactory.newPiece(tileState));
                    currCoord = currCoord.add(1, 0);
                }

                // If tileState is number, then advance currCoord by (int)tileState amount
                else currCoord = currCoord.add(tileState - '0', 0);
            }
            currCoord = new Coord(0, currCoord.y - 1);

        }
    }

    /**
     * Sets up the turnColor, castling, enPassantSquare, halfMoveClock and fullMoveNumber
     */
    private void setupBoardMisc(){
        turnColor = (boardSetup[1].equals("w")) ? playerColor.White: playerColor.Black;

        for (char c: boardSetup[2].toCharArray()) {
            if(c != '-'){
                castling.add(c);
            }
        }

        if(!boardSetup[3].equals("-")){
            char[] coordSetup = boardSetup[3].toCharArray();

            enPassantSquare = new Coord(
                    Character.toLowerCase(coordSetup[0]) - 'a',
                    coordSetup[1] - '1'
            );
        }else enPassantSquare = null;

        halfMoveClock = Integer.parseInt(boardSetup[4]);
        fullMoveNumber = Integer.parseInt(boardSetup[5]);

    }

    /**
     * Returns Piece obj located at (x, y), from this.state
     * @param x     x Coordinate
     * @param y     y Coordinate
     * @return      Piece located at (x,y)
     */
    public Piece pieceAt(int x, int y){
        return state.get(new Coord(x, y));
    }

    public Piece pieceAt(Coord coord){
        return state.get(coord);
    }


    public boolean hasPieceAt(Coord coord){
        return state.get(coord) != null && !(state.get(coord) instanceof Edge);
    }

    public boolean hasPieceAt(int x, int y){
        return hasPieceAt(new Coord(x, y));
    }

    /**
     * @param coord     Coord to see if it is in the board
     * @return          true if coord is within boardSize, and is not an Edge Piece
     */
    public boolean coordInBoard(Coord coord){
        return !(state.get(coord) instanceof Edge)
                && size[0] > coord.x && coord.x >= 0
                && size[1] > coord.y && coord.y >= 0;
    }

    public boolean coordInBoard(int x, int y){
        return coordInBoard(new Coord(x, y));
    }

    void movePiece(ChessTurn move){
        if(!hasPieceAt(move.moveFrom) || !coordInBoard(move.moveFrom) || !coordInBoard(move.moveTo)){
            throw new AssertionError("Move is on an empty square, or is not in the board.");
        }
        Piece pieceToMove = state.get(move.moveFrom);
        state.remove(move.moveFrom);
        if(hasPieceAt(move.moveTo)) state.replace(move.moveTo, pieceToMove);
        else state.put(move.moveTo, pieceToMove);

        if(turnColor == playerColor.White) turnColor = playerColor.Black;
        else{
            turnColor = playerColor.White;
            fullMoveNumber ++;
        }

        System.out.println("Piece Moved");
    }

    public Map<Coord, Piece> getBoard(){
        Map<Coord, Piece> boardState = new HashMap<>();
        for (Coord coord: state.keySet()) {
            boardState.put(new Coord(coord.x, coord.y), this.state.get(coord).clone());
        }
        return boardState;
    }

    /**
     * @param coord     coordinate to check the piece color of
     * @return          True if piece located at coord is the same color with the player who currently has the turn
     */
    boolean isAlliedPiece(Coord coord){
        if (hasPieceAt(coord)) return pieceAt(coord).color() == turnColor;
        return false;
    }

    playerColor currColor(){
        return turnColor;
    }
    Set<Character> castlingRights(){
        return castling;
    }
    Coord enPassantSquare(){
        return enPassantSquare;
    }
    private int halfMoveClock(){
        return halfMoveClock;
    }


    /** @return  piece placement part of FEN of current boardState. Also affects System.out.print */
    @Override
    public String toString() {

        char[][] pieceArray = new char[size[0]][size[1]];

        for (Coord coord: state.keySet()) {
            pieceArray[size[1] - 1 - coord.y][coord.x] = state.get(coord).FENChar();
        }

        StringBuilder strRepresentation = new StringBuilder();
        for (char[] row : pieceArray) {
            int i = 0;
            for(char tile : row){

                if(tile == '\u0000') i++;
                else{
                    if(i > 0) {
                        strRepresentation.append(i);
                        i = 0;
                    }
                    strRepresentation.append(tile);
                }
            }
            if(i > 0) strRepresentation.append(i);
            strRepresentation.append("/");
        }

        return getClass().getName() + " " + strRepresentation.substring(0, strRepresentation.length() - 1);
    }

}

